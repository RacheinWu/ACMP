# 求最大公约数， 这个是用辗转相除法
def gcd(x: int, y: int):
    while y != 0:
        t = x % y
        x = y
        y = t
    return x


# 根据题意，输入两个数字，这里默认是 a <= b
a, b = int(input()), int(input())
# 这个是有多少组（答案）
res = 0
"""
最大公约数乘最小公倍数等于两个正整数x。，y。的乘积。
"""
for i in range(a, b):
    for j in range(b, a):
        if gcd(i, j) == a and (i * j) == a * b:
            res += 1

'''
    上面的写法太暴力了，所以可以优化成一个for循环，只要找出i和j的关系
'''
# 为什么要从 [a, b+1] 这个区间开始呢？
# 首先：
# 对于最大公约数而言，
# 对于公倍数来说，不应该是这个公倍数 是 在这两个数之间取值的么，
# 比如 3 和 12， 既然是倍数了，那肯定是 大于或者等于这个数字，比如3的公倍数 就是3、6、9等等，对吧，所以就是要先从
for i in range(a, b + 1):
    # 这个t 代表待测的数
    t = a * b / i
    # 这里很关键，暴力算法是要运算很长时间，说白了，一句话就是：他们最大公倍数就是a*b了，公倍数肯定是在<=a*b里面的， 既然要求最小公倍数，
    # 就要想有没有一个数i 可以去约a*b，当然这个i不能乱取的，i可以从a开始，为什么？
    #
    # 首先gcd函数是我们写的求最大公约数的函数
    # i 是一开始的出发点， 比如我们3， 12是作为x0，y0，那么就先从3开始起步；
    # t 是刚刚算出来的数字，试着将这个组合去检测
    if gcd(i, t) == a and (i*t) / gcd(i, t) == b:
        # 如果这个组合是以a为最大公约数
        # 并且
        # 这两个数字的乘积 / 最大公约数 是等于b
        # 那么就符合题意
        res += 1


################################ 数学公式解析 ###############################
"""
    然后问题：为什么最小公倍数的公式是：(i, t) / gcd(i, t) == b: ->（最大公约数乘最小公倍数等于两个正整数x。，y。的乘积。）
        - 回答： 其实用逆向思维，
                首先你得把(i, t) / gcd(i, t) == b 进行拆分：
                就是：
                我们先称gcd(i,t) 是这两个数的最大公约数
                那么对(i, t) / gcd(i, t) == b 拆分就是：
                i / 最大公约数 * j
                或者
                j / 最大公约数 * i
                到这里，就很关键的思维了：
                因为我们都知道：
                i / 最大公约数，其实就是 i / 最大因子， 那么得出来的“结果”就是 i的最小因子
                那么i的最小因子 * 另一个数，自然也就是两个数的最小公倍数了，
                比如：
                3和12：
                最大公约数我们算出来是3，
                那么：
                对于3来说： 3 = 3 * 1， 那么1 就是3的最小因子了
                那么 然后继续将这个最小因子和12相乘： 1 * 12 就是12的倍数，也是3的倍数（因为里面1是3的因子，所以是3的倍数），
                而且因为1是3的“最小”因子，而且对于两个数之间最大的数而言（比如3，12的12），只要最大的数不动，本身就是自身（12）的最小倍数了，
                那么
                问题就解决了：
                对于12来说，自己最小的倍数自然是本身，
                对于3来说，因为1是它的最小因子，且因为 12= 1 * 12，所以12也是其倍数（因为1是3的因子），而且1是3的最小因子，
                所以：12就是两者的公倍数 且最小
                
                具体可以看严格的数学证明；最大公约数乘最小公倍数等于两个正整数x。，y。的乘积。
"""
print(res)
